#Acquire fastq files that you are interested in
#Assign Variables
ASSEMBLY='ftp://ftp.wormbase.org/pub/wormbase/releases/WS275/species/c_elegans/PRJNA13758/c_elegans.PRJNA13758.WS275.genomic.fa.gz'
ANNOTATION='ftp://ftp.wormbase.org/pub/wormbase/releases/WS275/species/c_elegans/PRJNA13758/c_elegans.PRJNA13758.WS275.canonical_geneset.gtf.gz'

################################
## Generate STAR Genome Index ##
################################

# Make a directory to store the genome files.
mkdir -p genome/index

# Download and unpack the genome assembly.
curl $ASSEMBLY | gunzip > ./genome/assembly.fasta

# Download and unpack the genome annotation.
curl $ANNOTATION | gunzip > ./genome/annotation.gtf

# Create the STAR genome index.
# --genomeSAindexNbases 12 was recommended by software.
#STAR version 2.7.10b
STAR \
  --runThreadN 4 \
  --runMode genomeGenerate \
  --genomeDir genome/index \
  --genomeFastaFiles genome/assembly.fasta \
  --sjdbGTFfile genome/annotation.gtf \
  --genomeSAindexNbases 12

###########################
## Align Reads to Genome ##
###########################

# Create an output directory for aligned reads.
mkdir -p results/aligned

# Align the reads.
FASTQ=$GSF3587*

for FASTQ in ${FASTQ[@]}; do
  PREFIX=results/aligned/$(basename $FASTQ .fastq)_
  STAR \
    --runThreadN 8 \
    --outFilterMultimapNmax 1 \
    --outFilterScoreMinOverLread .66 \
    --outFilterMismatchNmax 10 \
    --outFilterMismatchNoverLmax .3 \
    --runMode alignReads \
    --genomeDir genome/index \
    --readFilesIn $FASTQ \
    --outFileNamePrefix $PREFIX \
    --outSAMattributes All \
    --outSAMtype BAM SortedByCoordinate
done

# Indexing the BAM files.
BAMS=($(find ./results/aligned -name "*\.bam"))

for BAM in ${BAMS[@]}; do
  samtools index $BAM
  done

#If your genome annotation file does not contain introns directly annotated, generate a bed file containing intron sequence. 
import pysam
import pandas as pd

# Paths to files
bam_path = "your_reads.bam"
intron_bed_path = "introns.bed"

# Load introns into a dictionary by chromosome for fast lookup
introns = {}
with open(intron_bed_path) as f:
    for line in f:
        if line.startswith('#') or line.strip() == '':
            continue
        chrom, start, end = line.strip().split()[:3]
        start, end = int(start), int(end)
        if chrom not in introns:
            introns[chrom] = []
        introns[chrom].append((start, end))

# Open BAM
bamfile = pysam.AlignmentFile(bam_path, "rb")

# Function to check if any aligned read block overlaps an intron
def read_contains_intron(read, intron_list):
    # read.get_blocks() gives list of aligned blocks (start, end) in reference coordinates
    for block_start, block_end in read.get_blocks():
        for intron_start, intron_end in intron_list:
            # Check if block overlaps intron
            if block_end > intron_start and block_start < intron_end:
                return True
    return False

# Count reads containing intron sequence
count = 0
for read in bamfile.fetch():
    if read.is_unmapped:
        continue
    if read.reference_name not in introns:
        continue
    if read_contains_intron(read, introns[read.reference_name]):
        count += 1

print(f"Reads containing intron sequence: {count}")

#Convert your bam files from the alignment to bed files: 

bedtools bamtobed -split -i GSF1441-neural205-3_S19_R1_001_Aligned.sortedByCoord.out.bam > rep3mapped.bed


#Intersect your intron bed files and your experimental bed files: 

bedtools intersect \
  -a rep1mapped.bed \
  -b introns.bed \
  -u > rep1intronic_reads.bed

#Make output file: 

for f in rep*intronic_reads.bed; do     rep=$(basename "$f" intronic_reads.bed);     count=$(cut -f4 "$f" | sort -u | wc -l);     echo "$rep,$count" >> intronic_counts.csv; done
